// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dm

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// InstagramAccount is an object representing the database table.
type InstagramAccount struct {
	ID                    int         `boil:"id" json:"id" toml:"id" yaml:"id"`
	IsBusinessAccount     bool        `boil:"is_business_account" json:"is_business_account" toml:"is_business_account" yaml:"is_business_account"`
	IsProfessionalAccount bool        `boil:"is_professional_account" json:"is_professional_account" toml:"is_professional_account" yaml:"is_professional_account"`
	IsVerified            bool        `boil:"is_verified" json:"is_verified" toml:"is_verified" yaml:"is_verified"`
	Username              string      `boil:"username" json:"username" toml:"username" yaml:"username"`
	FullName              null.String `boil:"full_name" json:"full_name,omitempty" toml:"full_name" yaml:"full_name,omitempty"`
	ProfilePicture        string      `boil:"profile_picture" json:"profile_picture" toml:"profile_picture" yaml:"profile_picture"`
	PostCount             int         `boil:"post_count" json:"post_count" toml:"post_count" yaml:"post_count"`
	FollowersCount        int64       `boil:"followers_count" json:"followers_count" toml:"followers_count" yaml:"followers_count"`
	FollowingCount        int         `boil:"following_count" json:"following_count" toml:"following_count" yaml:"following_count"`
	ExternalURL           null.String `boil:"external_url" json:"external_url,omitempty" toml:"external_url" yaml:"external_url,omitempty"`
	BusinessEmail         null.String `boil:"business_email" json:"business_email,omitempty" toml:"business_email" yaml:"business_email,omitempty"`
	BusinessPhone         null.String `boil:"business_phone" json:"business_phone,omitempty" toml:"business_phone" yaml:"business_phone,omitempty"`
	BusinessCategory      null.String `boil:"business_category" json:"business_category,omitempty" toml:"business_category" yaml:"business_category,omitempty"`
	CategoryName          null.String `boil:"category_name" json:"category_name,omitempty" toml:"category_name" yaml:"category_name,omitempty"`
	Biography             null.String `boil:"biography" json:"biography,omitempty" toml:"biography" yaml:"biography,omitempty"`
	Email                 null.String `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	EmailProvider         null.String `boil:"email_provider" json:"email_provider,omitempty" toml:"email_provider" yaml:"email_provider,omitempty"`
	InstagramID           string      `boil:"instagram_id" json:"instagram_id" toml:"instagram_id" yaml:"instagram_id"`
	HasManagement         bool        `boil:"has_management" json:"has_management" toml:"has_management" yaml:"has_management"`

	R *instagramAccountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L instagramAccountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var InstagramAccountColumns = struct {
	ID                    string
	IsBusinessAccount     string
	IsProfessionalAccount string
	IsVerified            string
	Username              string
	FullName              string
	ProfilePicture        string
	PostCount             string
	FollowersCount        string
	FollowingCount        string
	ExternalURL           string
	BusinessEmail         string
	BusinessPhone         string
	BusinessCategory      string
	CategoryName          string
	Biography             string
	Email                 string
	EmailProvider         string
	InstagramID           string
	HasManagement         string
}{
	ID:                    "id",
	IsBusinessAccount:     "is_business_account",
	IsProfessionalAccount: "is_professional_account",
	IsVerified:            "is_verified",
	Username:              "username",
	FullName:              "full_name",
	ProfilePicture:        "profile_picture",
	PostCount:             "post_count",
	FollowersCount:        "followers_count",
	FollowingCount:        "following_count",
	ExternalURL:           "external_url",
	BusinessEmail:         "business_email",
	BusinessPhone:         "business_phone",
	BusinessCategory:      "business_category",
	CategoryName:          "category_name",
	Biography:             "biography",
	Email:                 "email",
	EmailProvider:         "email_provider",
	InstagramID:           "instagram_id",
	HasManagement:         "has_management",
}

var InstagramAccountTableColumns = struct {
	ID                    string
	IsBusinessAccount     string
	IsProfessionalAccount string
	IsVerified            string
	Username              string
	FullName              string
	ProfilePicture        string
	PostCount             string
	FollowersCount        string
	FollowingCount        string
	ExternalURL           string
	BusinessEmail         string
	BusinessPhone         string
	BusinessCategory      string
	CategoryName          string
	Biography             string
	Email                 string
	EmailProvider         string
	InstagramID           string
	HasManagement         string
}{
	ID:                    "instagram_accounts.id",
	IsBusinessAccount:     "instagram_accounts.is_business_account",
	IsProfessionalAccount: "instagram_accounts.is_professional_account",
	IsVerified:            "instagram_accounts.is_verified",
	Username:              "instagram_accounts.username",
	FullName:              "instagram_accounts.full_name",
	ProfilePicture:        "instagram_accounts.profile_picture",
	PostCount:             "instagram_accounts.post_count",
	FollowersCount:        "instagram_accounts.followers_count",
	FollowingCount:        "instagram_accounts.following_count",
	ExternalURL:           "instagram_accounts.external_url",
	BusinessEmail:         "instagram_accounts.business_email",
	BusinessPhone:         "instagram_accounts.business_phone",
	BusinessCategory:      "instagram_accounts.business_category",
	CategoryName:          "instagram_accounts.category_name",
	Biography:             "instagram_accounts.biography",
	Email:                 "instagram_accounts.email",
	EmailProvider:         "instagram_accounts.email_provider",
	InstagramID:           "instagram_accounts.instagram_id",
	HasManagement:         "instagram_accounts.has_management",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelperstring struct{ field string }

func (w whereHelperstring) EQ(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperstring) NEQ(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperstring) LT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperstring) LTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperstring) GT(x string) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperstring) GTE(x string) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperstring) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperstring) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var InstagramAccountWhere = struct {
	ID                    whereHelperint
	IsBusinessAccount     whereHelperbool
	IsProfessionalAccount whereHelperbool
	IsVerified            whereHelperbool
	Username              whereHelperstring
	FullName              whereHelpernull_String
	ProfilePicture        whereHelperstring
	PostCount             whereHelperint
	FollowersCount        whereHelperint64
	FollowingCount        whereHelperint
	ExternalURL           whereHelpernull_String
	BusinessEmail         whereHelpernull_String
	BusinessPhone         whereHelpernull_String
	BusinessCategory      whereHelpernull_String
	CategoryName          whereHelpernull_String
	Biography             whereHelpernull_String
	Email                 whereHelpernull_String
	EmailProvider         whereHelpernull_String
	InstagramID           whereHelperstring
	HasManagement         whereHelperbool
}{
	ID:                    whereHelperint{field: "\"instagram_accounts\".\"id\""},
	IsBusinessAccount:     whereHelperbool{field: "\"instagram_accounts\".\"is_business_account\""},
	IsProfessionalAccount: whereHelperbool{field: "\"instagram_accounts\".\"is_professional_account\""},
	IsVerified:            whereHelperbool{field: "\"instagram_accounts\".\"is_verified\""},
	Username:              whereHelperstring{field: "\"instagram_accounts\".\"username\""},
	FullName:              whereHelpernull_String{field: "\"instagram_accounts\".\"full_name\""},
	ProfilePicture:        whereHelperstring{field: "\"instagram_accounts\".\"profile_picture\""},
	PostCount:             whereHelperint{field: "\"instagram_accounts\".\"post_count\""},
	FollowersCount:        whereHelperint64{field: "\"instagram_accounts\".\"followers_count\""},
	FollowingCount:        whereHelperint{field: "\"instagram_accounts\".\"following_count\""},
	ExternalURL:           whereHelpernull_String{field: "\"instagram_accounts\".\"external_url\""},
	BusinessEmail:         whereHelpernull_String{field: "\"instagram_accounts\".\"business_email\""},
	BusinessPhone:         whereHelpernull_String{field: "\"instagram_accounts\".\"business_phone\""},
	BusinessCategory:      whereHelpernull_String{field: "\"instagram_accounts\".\"business_category\""},
	CategoryName:          whereHelpernull_String{field: "\"instagram_accounts\".\"category_name\""},
	Biography:             whereHelpernull_String{field: "\"instagram_accounts\".\"biography\""},
	Email:                 whereHelpernull_String{field: "\"instagram_accounts\".\"email\""},
	EmailProvider:         whereHelpernull_String{field: "\"instagram_accounts\".\"email_provider\""},
	InstagramID:           whereHelperstring{field: "\"instagram_accounts\".\"instagram_id\""},
	HasManagement:         whereHelperbool{field: "\"instagram_accounts\".\"has_management\""},
}

// InstagramAccountRels is where relationship names are stored.
var InstagramAccountRels = struct {
}{}

// instagramAccountR is where relationships are stored.
type instagramAccountR struct {
}

// NewStruct creates a new relationship struct
func (*instagramAccountR) NewStruct() *instagramAccountR {
	return &instagramAccountR{}
}

// instagramAccountL is where Load methods for each relationship are stored.
type instagramAccountL struct{}

var (
	instagramAccountAllColumns            = []string{"id", "is_business_account", "is_professional_account", "is_verified", "username", "full_name", "profile_picture", "post_count", "followers_count", "following_count", "external_url", "business_email", "business_phone", "business_category", "category_name", "biography", "email", "email_provider", "instagram_id", "has_management"}
	instagramAccountColumnsWithoutDefault = []string{"is_business_account", "is_professional_account", "is_verified", "username", "profile_picture", "post_count", "followers_count", "following_count", "instagram_id"}
	instagramAccountColumnsWithDefault    = []string{"id", "full_name", "external_url", "business_email", "business_phone", "business_category", "category_name", "biography", "email", "email_provider", "has_management"}
	instagramAccountPrimaryKeyColumns     = []string{"id"}
	instagramAccountGeneratedColumns      = []string{}
)

type (
	// InstagramAccountSlice is an alias for a slice of pointers to InstagramAccount.
	// This should almost always be used instead of []InstagramAccount.
	InstagramAccountSlice []*InstagramAccount
	// InstagramAccountHook is the signature for custom InstagramAccount hook methods
	InstagramAccountHook func(context.Context, boil.ContextExecutor, *InstagramAccount) error

	instagramAccountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	instagramAccountType                 = reflect.TypeOf(&InstagramAccount{})
	instagramAccountMapping              = queries.MakeStructMapping(instagramAccountType)
	instagramAccountPrimaryKeyMapping, _ = queries.BindMapping(instagramAccountType, instagramAccountMapping, instagramAccountPrimaryKeyColumns)
	instagramAccountInsertCacheMut       sync.RWMutex
	instagramAccountInsertCache          = make(map[string]insertCache)
	instagramAccountUpdateCacheMut       sync.RWMutex
	instagramAccountUpdateCache          = make(map[string]updateCache)
	instagramAccountUpsertCacheMut       sync.RWMutex
	instagramAccountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var instagramAccountAfterSelectHooks []InstagramAccountHook

var instagramAccountBeforeInsertHooks []InstagramAccountHook
var instagramAccountAfterInsertHooks []InstagramAccountHook

var instagramAccountBeforeUpdateHooks []InstagramAccountHook
var instagramAccountAfterUpdateHooks []InstagramAccountHook

var instagramAccountBeforeDeleteHooks []InstagramAccountHook
var instagramAccountAfterDeleteHooks []InstagramAccountHook

var instagramAccountBeforeUpsertHooks []InstagramAccountHook
var instagramAccountAfterUpsertHooks []InstagramAccountHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *InstagramAccount) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *InstagramAccount) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *InstagramAccount) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *InstagramAccount) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *InstagramAccount) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *InstagramAccount) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *InstagramAccount) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *InstagramAccount) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *InstagramAccount) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range instagramAccountAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddInstagramAccountHook registers your hook function for all future operations.
func AddInstagramAccountHook(hookPoint boil.HookPoint, instagramAccountHook InstagramAccountHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		instagramAccountAfterSelectHooks = append(instagramAccountAfterSelectHooks, instagramAccountHook)
	case boil.BeforeInsertHook:
		instagramAccountBeforeInsertHooks = append(instagramAccountBeforeInsertHooks, instagramAccountHook)
	case boil.AfterInsertHook:
		instagramAccountAfterInsertHooks = append(instagramAccountAfterInsertHooks, instagramAccountHook)
	case boil.BeforeUpdateHook:
		instagramAccountBeforeUpdateHooks = append(instagramAccountBeforeUpdateHooks, instagramAccountHook)
	case boil.AfterUpdateHook:
		instagramAccountAfterUpdateHooks = append(instagramAccountAfterUpdateHooks, instagramAccountHook)
	case boil.BeforeDeleteHook:
		instagramAccountBeforeDeleteHooks = append(instagramAccountBeforeDeleteHooks, instagramAccountHook)
	case boil.AfterDeleteHook:
		instagramAccountAfterDeleteHooks = append(instagramAccountAfterDeleteHooks, instagramAccountHook)
	case boil.BeforeUpsertHook:
		instagramAccountBeforeUpsertHooks = append(instagramAccountBeforeUpsertHooks, instagramAccountHook)
	case boil.AfterUpsertHook:
		instagramAccountAfterUpsertHooks = append(instagramAccountAfterUpsertHooks, instagramAccountHook)
	}
}

// One returns a single instagramAccount record from the query.
func (q instagramAccountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*InstagramAccount, error) {
	o := &InstagramAccount{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dm: failed to execute a one query for instagram_accounts")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all InstagramAccount records from the query.
func (q instagramAccountQuery) All(ctx context.Context, exec boil.ContextExecutor) (InstagramAccountSlice, error) {
	var o []*InstagramAccount

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dm: failed to assign all query results to InstagramAccount slice")
	}

	if len(instagramAccountAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all InstagramAccount records in the query.
func (q instagramAccountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dm: failed to count instagram_accounts rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q instagramAccountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dm: failed to check if instagram_accounts exists")
	}

	return count > 0, nil
}

// InstagramAccounts retrieves all the records using an executor.
func InstagramAccounts(mods ...qm.QueryMod) instagramAccountQuery {
	mods = append(mods, qm.From("\"instagram_accounts\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"instagram_accounts\".*"})
	}

	return instagramAccountQuery{q}
}

// FindInstagramAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindInstagramAccount(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*InstagramAccount, error) {
	instagramAccountObj := &InstagramAccount{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"instagram_accounts\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, instagramAccountObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dm: unable to select from instagram_accounts")
	}

	if err = instagramAccountObj.doAfterSelectHooks(ctx, exec); err != nil {
		return instagramAccountObj, err
	}

	return instagramAccountObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *InstagramAccount) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dm: no instagram_accounts provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(instagramAccountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	instagramAccountInsertCacheMut.RLock()
	cache, cached := instagramAccountInsertCache[key]
	instagramAccountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			instagramAccountAllColumns,
			instagramAccountColumnsWithDefault,
			instagramAccountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(instagramAccountType, instagramAccountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(instagramAccountType, instagramAccountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"instagram_accounts\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"instagram_accounts\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dm: unable to insert into instagram_accounts")
	}

	if !cached {
		instagramAccountInsertCacheMut.Lock()
		instagramAccountInsertCache[key] = cache
		instagramAccountInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the InstagramAccount.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *InstagramAccount) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	instagramAccountUpdateCacheMut.RLock()
	cache, cached := instagramAccountUpdateCache[key]
	instagramAccountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			instagramAccountAllColumns,
			instagramAccountPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("dm: unable to update instagram_accounts, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"instagram_accounts\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, instagramAccountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(instagramAccountType, instagramAccountMapping, append(wl, instagramAccountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to update instagram_accounts row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: failed to get rows affected by update for instagram_accounts")
	}

	if !cached {
		instagramAccountUpdateCacheMut.Lock()
		instagramAccountUpdateCache[key] = cache
		instagramAccountUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q instagramAccountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to update all for instagram_accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to retrieve rows affected for instagram_accounts")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o InstagramAccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dm: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), instagramAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"instagram_accounts\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, instagramAccountPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to update all in instagramAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to retrieve rows affected all in update all instagramAccount")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *InstagramAccount) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dm: no instagram_accounts provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(instagramAccountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	instagramAccountUpsertCacheMut.RLock()
	cache, cached := instagramAccountUpsertCache[key]
	instagramAccountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			instagramAccountAllColumns,
			instagramAccountColumnsWithDefault,
			instagramAccountColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			instagramAccountAllColumns,
			instagramAccountPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dm: unable to upsert instagram_accounts, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(instagramAccountPrimaryKeyColumns))
			copy(conflict, instagramAccountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"instagram_accounts\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(instagramAccountType, instagramAccountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(instagramAccountType, instagramAccountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dm: unable to upsert instagram_accounts")
	}

	if !cached {
		instagramAccountUpsertCacheMut.Lock()
		instagramAccountUpsertCache[key] = cache
		instagramAccountUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single InstagramAccount record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *InstagramAccount) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dm: no InstagramAccount provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), instagramAccountPrimaryKeyMapping)
	sql := "DELETE FROM \"instagram_accounts\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to delete from instagram_accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: failed to get rows affected by delete for instagram_accounts")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q instagramAccountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dm: no instagramAccountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to delete all from instagram_accounts")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: failed to get rows affected by deleteall for instagram_accounts")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o InstagramAccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(instagramAccountBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), instagramAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"instagram_accounts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, instagramAccountPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dm: unable to delete all from instagramAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dm: failed to get rows affected by deleteall for instagram_accounts")
	}

	if len(instagramAccountAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *InstagramAccount) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindInstagramAccount(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *InstagramAccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := InstagramAccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), instagramAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"instagram_accounts\".* FROM \"instagram_accounts\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, instagramAccountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dm: unable to reload all in InstagramAccountSlice")
	}

	*o = slice

	return nil
}

// InstagramAccountExists checks if the InstagramAccount row exists.
func InstagramAccountExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"instagram_accounts\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dm: unable to check if instagram_accounts exists")
	}

	return exists, nil
}
